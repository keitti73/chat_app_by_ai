# チャットアプリ - データベース設計詳細書

## 1. システム概要

このチャットアプリは、AWS AppSyncとDynamoDBを使用したサーバーレスリアルタイムメッセージングシステムです。NoSQLデータベース設計の特徴を活かし、高いスケーラビリティと可用性を実現しています。

```mermaid
flowchart TB
    subgraph "Frontend Layer"
        React[React Application]
        GraphQL[GraphQL Client]
    end
    
    subgraph "API Layer"
        AppSync[AWS AppSync]
        Cognito[Amazon Cognito]
        Resolvers[JavaScript Resolvers]
    end
    
    subgraph "Data Layer"
        DynamoDB[(DynamoDB)]
        subgraph "Tables"
            RoomTable[Room Table]
            MessageTable[Message Table]
        end
    end
    
    React --> GraphQL
    GraphQL --> AppSync
    AppSync --> Cognito
    AppSync --> Resolvers
    Resolvers --> DynamoDB
    DynamoDB --> RoomTable
    DynamoDB --> MessageTable
```

## 2. データベース技術選択理由

### 2.1 DynamoDB選択理由

```mermaid
flowchart TB
    subgraph "データベース性能・コスト比較"
        direction TB
        
        subgraph High_Performance["高性能"]
            DynamoDB["🚀 DynamoDB<br/>高性能・高コスト"]
            Redis["⚡ Redis<br/>超高性能・低コスト"]
            MongoDB["🍃 MongoDB<br/>高性能・中コスト"]
        end
        
        subgraph Mid_Performance["中性能"]
            PostgreSQL["🐘 PostgreSQL<br/>中性能・中コスト"]
            MySQL["🐬 MySQL<br/>中性能・低コスト"]
        end
    end
    
    style DynamoDB fill:#ff9999,stroke:#333,stroke-width:3px
    style Redis fill:#99ff99,stroke:#333,stroke-width:2px
    style MongoDB fill:#ffff99,stroke:#333,stroke-width:2px
    style PostgreSQL fill:#99ccff,stroke:#333,stroke-width:2px
    style MySQL fill:#ccccff,stroke:#333,stroke-width:2px
```

| 特徴 | DynamoDB | PostgreSQL | MongoDB |
|------|----------|------------|---------|
| スケーラビリティ | ★★★★★ | ★★★ | ★★★★ |
| レスポンス時間 | ★★★★★ | ★★★ | ★★★★ |
| 運用コスト | ★★★★ | ★★ | ★★★ |
| リアルタイム性 | ★★★★★ | ★★ | ★★★ |
| 学習コスト | ★★★ | ★★★★ | ★★★★ |

### 2.2 NoSQL設計原則

```mermaid
flowchart TD
    Root["🎯 NoSQL設計原則"] --> A["📊 非正規化"]
    Root --> B["🎯 アクセスパターン主導"]
    Root --> C["📈 スケーラビリティ"]
    Root --> D["⚡ パフォーマンス"]
    
    A --> A1["データ重複を許容"]
    A --> A2["読み取り最適化"]
    A --> A3["結合操作の回避"]
    
    B --> B1["クエリファースト設計"]
    B --> B2["インデックス戦略"]
    B --> B3["パーティション設計"]
    
    C --> C1["水平分散"]
    C --> C2["ホットパーティション回避"]
    C --> C3["自動スケーリング"]
    
    D --> D1["単一桁ミリ秒レスポンス"]
    D --> D2["スループット保証"]
    D --> D3["予測可能なパフォーマンス"]
    
    style Root fill:#ff9999,stroke:#333,stroke-width:3px
    style A fill:#ffcc99,stroke:#333,stroke-width:2px
    style B fill:#99ccff,stroke:#333,stroke-width:2px
    style C fill:#99ff99,stroke:#333,stroke-width:2px
    style D fill:#ffff99,stroke:#333,stroke-width:2px
```

## 3. テーブル設計詳細

### 3.1 Roomテーブル設計

```mermaid
classDiagram
    class ROOM {
        +string id PK
        +string name
        +string owner
        +string createdAt
    }
    
    class ROOM_GSI1 {
        +string owner PK
        +string id SK
        +string name
        +string createdAt
    }
```

#### 3.1.1 アクセスパターン分析

```mermaid
flowchart LR
    subgraph "Primary Key Access"
        PK1[id → ルーム詳細取得]
    end
    
    subgraph "GSI1 Access"
        GSI1[owner → 作成ルーム一覧]
    end
    
    subgraph "Use Cases"
        UC1[ルーム情報表示]
        UC2[マイルーム一覧]
        UC3[ルーム作成]
        UC4[ルーム削除]
    end
    
    UC1 --> PK1
    UC2 --> GSI1
    UC3 --> PK1
    UC4 --> PK1
```

#### 3.1.2 データサンプル

| id | name | owner | createdAt |
|----|------|-------|-----------|
| `room_001` | "開発チーム" | "alice" | "2025-01-01T09:00:00Z" |
| `room_002` | "雑談部屋" | "bob" | "2025-01-02T10:30:00Z" |
| `room_003` | "プロジェクトA" | "alice" | "2025-01-03T14:15:00Z" |

### 3.2 Messageテーブル設計

```mermaid
classDiagram
    class MESSAGE {
        +string id PK
        +string text
        +string user
        +string roomId
        +string createdAt
    }
    
    class MESSAGE_GSI1 {
        +string user PK
        +string createdAt SK
        +string roomId
        +string text
    }
    
    class MESSAGE_GSI2 {
        +string roomId PK
        +string createdAt SK
        +string user
        +string text
    }
```

#### 3.2.1 アクセスパターン分析

```mermaid
flowchart TB
    subgraph "Query Patterns"
        Q1[特定メッセージ取得<br/>id]
        Q2[ユーザー投稿履歴<br/>user + createdAt]
        Q3[ルーム内メッセージ<br/>roomId + createdAt]
        Q4[アクティブルーム検索<br/>user → distinct roomId]
    end
    
    subgraph "Index Usage"
        PK[Primary Key<br/>id]
        GSI1[user-index<br/>user, createdAt]
        GSI2[room-index<br/>roomId, createdAt]
    end
    
    Q1 --> PK
    Q2 --> GSI1
    Q3 --> GSI2
    Q4 --> GSI1
```

#### 3.2.2 時系列データの最適化

```mermaid
sequenceDiagram
    participant Client as クライアント
    participant API as AppSync
    participant GSI as room-index
    participant Table as Messageテーブル
    
    Note over Client,Table: 最新50件のメッセージ取得
    
    Client->>API: listMessages(roomId, limit=50)
    API->>GSI: Query roomId, scanIndexForward=false
    GSI->>Table: 最新順でデータ取得
    Table-->>GSI: 結果返却
    GSI-->>API: ソート済みデータ
    API-->>Client: 最新50件のメッセージ
```

#### 3.2.3 データサンプル

| id | text | user | roomId | createdAt |
|----|------|------|--------|-----------|
| `msg_001` | "おはようございます！" | "alice" | "room_001" | "2025-01-01T09:05:00Z" |
| `msg_002` | "今日の進捗はどうですか？" | "bob" | "room_001" | "2025-01-01T09:10:00Z" |
| `msg_003` | "バグを修正しました" | "alice" | "room_001" | "2025-01-01T09:15:00Z" |

## 4. インデックス戦略

### 4.1 Global Secondary Index設計

```mermaid
flowchart TB
    subgraph "Room Table"
        RPK[Primary Key: id]
        RGSI1[GSI1: owner-index]
    end
    
    subgraph "Message Table"
        MPK[Primary Key: id]
        MGSI1[GSI1: user-index]
        MGSI2[GSI2: room-index]
    end
    
    subgraph "Access Patterns"
        AP1[ルーム詳細取得]
        AP2[作成ルーム一覧]
        AP3[メッセージ詳細]
        AP4[ユーザー投稿履歴]
        AP5[ルーム内メッセージ]
    end
    
    AP1 --> RPK
    AP2 --> RGSI1
    AP3 --> MPK
    AP4 --> MGSI1
    AP5 --> MGSI2
```

## 5. パーティション設計

### 5.1 ホットパーティション回避戦略

```mermaid
gantt
    title パーティション負荷分散シミュレーション
    dateFormat X
    axisFormat %H:%M
    
    section Partition A
    Low Load    :a1, 0, 8
    Medium Load :a2, 8, 4
    High Load   :a3, 12, 2
    Low Load    :a4, 14, 10
    
    section Partition B
    Medium Load :b1, 0, 6
    High Load   :b2, 6, 3
    Low Load    :b3, 9, 6
    Medium Load :b4, 15, 9
    
    section Partition C
    High Load   :c1, 0, 3
    Low Load    :c2, 3, 8
    Medium Load :c3, 11, 5
    High Load   :c4, 16, 8
```

### 5.2 スケーラビリティ考慮事項

```mermaid
flowchart LR
    subgraph "Data Distribution"
        A[ユーザーID Hash] --> B[パーティション1]
        A --> C[パーティション2]
        A --> D[パーティション3]
        A --> E[パーティションN]
    end
    
    subgraph "Load Balancing"
        F[Auto Scaling] --> G[Read Capacity]
        F --> H[Write Capacity]
        I[CloudWatch] --> F
    end
    
    B --> F
    C --> F
    D --> F
    E --> F
```

## 6. データモデリングパターン

### 6.1 One-to-Many関係の実装

```mermaid
classDiagram
    class Room {
        +string id
        +string name
        +string owner
        +string createdAt
        +getMessages() Message[]
    }
    
    class Message {
        +string id
        +string text
        +string user
        +string roomId
        +string createdAt
        +getRoom() Room
    }
    
    Room "1" --> "0..*" Message : contains
```

### 6.2 非正規化データパターン

```mermaid
flowchart TB
    subgraph "Normalized (RDBMS Pattern)"
        N1[Room Table] --> N2[Message Table]
        N2 --> N3[User Table]
        N4[JOIN Operations Required]
    end
    
    subgraph "Denormalized (NoSQL Pattern)"
        D1[Message Table<br/>+ user name<br/>+ room name]
        D2[Single Query Access]
    end
    
    N4 -.->|Transform| D2
    
    style N4 fill:#ff6b6b
    style D2 fill:#51cf66
```

## 7. 容量設計

### 8.1 ストレージ容量見積もり

```mermaid
flowchart TB
    subgraph "Capacity Planning"
        A[日次メッセージ数<br/>10,000件] --> B[1メッセージ平均<br/>500 bytes]
        B --> C[日次データ増加<br/>5MB]
        C --> D[年間データ増加<br/>1.8GB]
        D --> E[3年保持<br/>5.4GB]
    end
    
    subgraph "Storage Cost"
        F[$0.25/GB/月]
        E --> F
        F --> G[月額 $1.35]
    end
```

### 8.2 トラフィック設計

```mermaid
flowchart TB
    subgraph "24時間のトラフィックパターン"
        A[深夜 00-06時<br/>平日: 50-200 RCU/秒<br/>休日: 30-100 RCU/秒] 
        B[朝 06-12時<br/>平日: 200-950 RCU/秒<br/>休日: 100-600 RCU/秒]
        C[昼 12-18時<br/>平日: 600-900 RCU/秒<br/>休日: 650-800 RCU/秒]
        D[夜 18-24時<br/>平日: 400-600 RCU/秒<br/>休日: 300-600 RCU/秒]
    end
    
    A --> B
    B --> C  
    C --> D
    D --> A
    
    style B fill:#ff6b6b
    style C fill:#ffd93d
    style A fill:#6bcf7f
    style D fill:#4d96ff
```

**トラフィック特性:**
- **ピーク時間**: 平日 09:00-10:00 (950 RCU/秒)
- **オフピーク**: 深夜 02:00-05:00 (50 RCU/秒)
- **休日パターン**: より均等な分散、ピークは低め

## 9. 監視・運用

### 9.1 メトリクス監視

```mermaid
flowchart TD
    Root["📊 DynamoDB監視"] --> A["⚡ パフォーマンス"]
    Root --> B["💾 容量"]
    Root --> C["💰 コスト"]
    Root --> D["❌ エラー"]
    
    A --> A1["読み取りレイテンシ"]
    A --> A2["書き込みレイテンシ"]
    A --> A3["スロットルエラー"]
    A --> A4["成功率"]
    
    B --> B1["消費RCU/WCU"]
    B --> B2["ストレージ使用量"]
    B --> B3["インデックスサイズ"]
    
    C --> C1["RCU/WCUコスト"]
    C --> C2["ストレージコスト"]
    C --> C3["データ転送コスト"]
    
    D --> D1["4xx エラー"]
    D --> D2["5xx エラー"]
    D --> D3["タイムアウト"]
    D --> D4["リトライ回数"]
    
    style Root fill:#ff9999,stroke:#333,stroke-width:3px
    style A fill:#ffcc99,stroke:#333,stroke-width:2px
    style B fill:#99ccff,stroke:#333,stroke-width:2px
    style C fill:#99ff99,stroke:#333,stroke-width:2px
    style D fill:#ffaaaa,stroke:#333,stroke-width:2px
```

### 9.2 アラート設定

```mermaid
flowchart TB
    subgraph "Monitoring Metrics"
        M1[Read Latency > 100ms]
        M2[Write Latency > 50ms]
        M3[Error Rate > 1%]
        M4[Throttling > 0]
        M5[Capacity > 80%]
    end
    
    subgraph "Alert Actions"
        A1[Slack通知]
        A2[メール通知]
        A3[Auto Scaling]
        A4[Lambda関数実行]
    end
    
    M1 --> A1
    M2 --> A1
    M3 --> A2
    M4 --> A3
    M5 --> A3
```

## 10. セキュリティ設計

### 10.1 データ保護

```mermaid
flowchart LR
    subgraph "Data Protection"
        A[Encryption at Rest<br/>KMS] --> B[Encryption in Transit<br/>TLS 1.2+]
        B --> C[Access Control<br/>IAM Roles]
        C --> D[Audit Logging<br/>CloudTrail]
    end
    
    subgraph "Security Measures"
        E[VPC Endpoints]
        F[Resource-based Policies]
        G[Fine-grained Access]
        H[Backup Encryption]
    end
    
    A --> E
    B --> F
    C --> G
    D --> H
```

### 10.2 アクセス制御

```mermaid
sequenceDiagram
    participant User as ユーザー
    participant Cognito as Cognito
    participant AppSync as AppSync
    participant IAM as IAM Role
    participant DDB as DynamoDB
    
    User->>Cognito: 認証
    Cognito-->>User: JWT Token
    User->>AppSync: GraphQL Request + Token
    AppSync->>IAM: AssumeRole
    IAM-->>AppSync: Temporary Credentials
    AppSync->>DDB: Query with Credentials
    DDB-->>AppSync: Response
    AppSync-->>User: GraphQL Response
```

## 11. 災害復旧・バックアップ

### 11.1 バックアップ戦略

```mermaid
flowchart LR
    subgraph "📅 バックアップ・復旧戦略"
        direction TB
        
        subgraph "🔄 自動バックアップ"
            A1["Point-in-time Recovery<br/>継続的バックアップ<br/>35日間保持"]
        end
        
        subgraph "📋 手動バックアップ"
            B1["週次フルバックアップ<br/>完全なテーブルバックアップ<br/>1年間保持"]
        end
        
        subgraph "🌍 Cross-Region"
            C1["DynamoDB Global Tables<br/>別リージョン複製<br/>災害復旧用"]
        end
    end
    
    style A1 fill:#99ff99,stroke:#333,stroke-width:2px
    style B1 fill:#ffcc99,stroke:#333,stroke-width:2px
    style C1 fill:#ff9999,stroke:#333,stroke-width:2px
```

### 11.2 復旧手順

```mermaid
flowchart TB
    A[障害検知] --> B{影響範囲判定}
    B -->|部分障害| C[Point-in-time Recovery]
    B -->|全体障害| D[Cross-Region Failover]
    B -->|データ破損| E[手動バックアップから復旧]
    
    C --> F[データ整合性確認]
    D --> F
    E --> F
    
    F --> G[アプリケーション復旧確認]
    G --> H[監視システム復旧]
    H --> I[ユーザー通知]
```

---

*このドキュメントは、チャットアプリのDynamoDBデータベース設計の詳細を説明しています。NoSQL設計原則に基づき、スケーラブルで高性能なデータストアを実現しています。*
